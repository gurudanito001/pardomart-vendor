/* tslint:disable */
/* eslint-disable */
/**
 * PardoMart Node API
 * API documentation for the PardoMart Node.js application.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@pardomart.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { AxiosInstance, AxiosPromise, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import type { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, createRequestFunction, serializeDataIfNeeded, setBearerAuthToObject, setSearchParams, toPathString } from '../common';
// @ts-ignore
import { BASE_PATH, BaseAPI, RequiredError, operationServerMap, type RequestArgs } from '../base';
// @ts-ignore
import type { CreateVendorPayload } from '../models';
// @ts-ignore
import type { DeclineOrderPayload } from '../models';
// @ts-ignore
import type { Order } from '../models';
// @ts-ignore
import type { OrderItemWithRelations } from '../models';
// @ts-ignore
import type { OrderStatus } from '../models';
// @ts-ignore
import type { PaginatedTrendingVendorProducts } from '../models';
// @ts-ignore
import type { PaginatedVendors } from '../models';
// @ts-ignore
import type { UpdateOrderItemShoppingStatusPayload } from '../models';
// @ts-ignore
import type { UpdateVendorPayload } from '../models';
// @ts-ignore
import type { VendorOrder } from '../models';
// @ts-ignore
import type { VendorWithDetails } from '../models';
// @ts-ignore
import type { VendorWithRelations } from '../models';
/**
 * VendorApi - axios parameter creator
 */
export const VendorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accept a pending order
         * @param {string} orderId The ID of the order to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdAcceptPatch: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdAcceptPatch', 'orderId', orderId)
            const localVarPath = `/order/{orderId}/accept`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Decline a pending order
         * @param {string} orderId The ID of the order to decline.
         * @param {DeclineOrderPayload} [declineOrderPayload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdDeclinePatch: async (orderId: string, declineOrderPayload?: DeclineOrderPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdDeclinePatch', 'orderId', orderId)
            const localVarPath = `/order/{orderId}/decline`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(declineOrderPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the assigned shopper or delivery person to update an item\'s status during shopping (e.g., found, not found, suggest replacement).
         * @summary Update the shopping status of an order item
         * @param {UpdateOrderItemShoppingStatusPayload} updateOrderItemShoppingStatusPayload 
         * @param {string} orderId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdItemsItemIdUpdateShoppingStatusPatch: async (updateOrderItemShoppingStatusPayload: UpdateOrderItemShoppingStatusPayload, orderId: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateOrderItemShoppingStatusPayload' is not null or undefined
            assertParamExists('orderOrderIdItemsItemIdUpdateShoppingStatusPatch', 'updateOrderItemShoppingStatusPayload', updateOrderItemShoppingStatusPayload)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdItemsItemIdUpdateShoppingStatusPatch', 'orderId', orderId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('orderOrderIdItemsItemIdUpdateShoppingStatusPatch', 'itemId', itemId)
            const localVarPath = `/order/{orderId}/items/{itemId}/update-shopping-status`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrderItemShoppingStatusPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark an order as \'currently shopping\'
         * @param {string} orderId The ID of the order to start shopping for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdStartShoppingPatch: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdStartShoppingPatch', 'orderId', orderId)
            const localVarPath = `/order/{orderId}/start-shopping`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get orders for a vendor\'s dashboard
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderVendorOrdersGet: async (status?: OrderStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/vendorOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
         * @summary Get trending vendor products
         * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTrendingGet: async (vendorId?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/vendor/trending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of vendors. Can be filtered by name and sorted by proximity if latitude and longitude are provided. If the user is authenticated, it also returns the number of items in their cart for each vendor.
         * @summary Get a paginated list of vendors
         * @param {string} [name] Filter vendors by name (case-insensitive search).
         * @param {number} [latitude] User\&#39;s current latitude to sort vendors by distance.
         * @param {number} [longitude] User\&#39;s current longitude to sort vendors by distance.
         * @param {string} [userId] Filter vendors by the user who owns them.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsGet: async (name?: string, latitude?: number, longitude?: number, userId?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vendors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all vendors associated with the currently authenticated user.
         * @summary Get all vendors for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsGetvendorsbyUserIdGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vendors/getvendorsby/userId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a vendor
         * @param {string} id The ID of the vendor to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('vendorsIdDelete', 'id', id)
            const localVarPath = `/vendors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a vendor by its ID
         * @param {string} id The ID of the vendor to retrieve.
         * @param {number} [latitude] User\&#39;s current latitude to calculate distance to the vendor.
         * @param {number} [longitude] User\&#39;s current longitude to calculate distance to the vendor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdGet: async (id: string, latitude?: number, longitude?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('vendorsIdGet', 'id', id)
            const localVarPath = `/vendors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a vendor\'s details
         * @param {UpdateVendorPayload} updateVendorPayload 
         * @param {string} id The ID of the vendor to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdPatch: async (updateVendorPayload: UpdateVendorPayload, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateVendorPayload' is not null or undefined
            assertParamExists('vendorsIdPatch', 'updateVendorPayload', updateVendorPayload)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('vendorsIdPatch', 'id', id)
            const localVarPath = `/vendors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVendorPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new vendor profile linked to the authenticated user. Default opening hours from 9:00 to 18:00 are created automatically for all days of the week.
         * @summary Create a new vendor
         * @param {CreateVendorPayload} createVendorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsPost: async (createVendorPayload: CreateVendorPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVendorPayload' is not null or undefined
            assertParamExists('vendorsPost', 'createVendorPayload', createVendorPayload)
            const localVarPath = `/vendors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVendorPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VendorApi - functional programming interface
 */
export const VendorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VendorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accept a pending order
         * @param {string} orderId The ID of the order to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdAcceptPatch(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdAcceptPatch(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.orderOrderIdAcceptPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Decline a pending order
         * @param {string} orderId The ID of the order to decline.
         * @param {DeclineOrderPayload} [declineOrderPayload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdDeclinePatch(orderId: string, declineOrderPayload?: DeclineOrderPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdDeclinePatch(orderId, declineOrderPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.orderOrderIdDeclinePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the assigned shopper or delivery person to update an item\'s status during shopping (e.g., found, not found, suggest replacement).
         * @summary Update the shopping status of an order item
         * @param {UpdateOrderItemShoppingStatusPayload} updateOrderItemShoppingStatusPayload 
         * @param {string} orderId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdItemsItemIdUpdateShoppingStatusPatch(updateOrderItemShoppingStatusPayload: UpdateOrderItemShoppingStatusPayload, orderId: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdItemsItemIdUpdateShoppingStatusPatch(updateOrderItemShoppingStatusPayload, orderId, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.orderOrderIdItemsItemIdUpdateShoppingStatusPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Mark an order as \'currently shopping\'
         * @param {string} orderId The ID of the order to start shopping for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdStartShoppingPatch(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdStartShoppingPatch(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.orderOrderIdStartShoppingPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get orders for a vendor\'s dashboard
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderVendorOrdersGet(status?: OrderStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorOrder>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderVendorOrdersGet(status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.orderVendorOrdersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
         * @summary Get trending vendor products
         * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorTrendingGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTrendingVendorProducts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorTrendingGet(vendorId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.productVendorTrendingGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of vendors. Can be filtered by name and sorted by proximity if latitude and longitude are provided. If the user is authenticated, it also returns the number of items in their cart for each vendor.
         * @summary Get a paginated list of vendors
         * @param {string} [name] Filter vendors by name (case-insensitive search).
         * @param {number} [latitude] User\&#39;s current latitude to sort vendors by distance.
         * @param {number} [longitude] User\&#39;s current longitude to sort vendors by distance.
         * @param {string} [userId] Filter vendors by the user who owns them.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsGet(name?: string, latitude?: number, longitude?: number, userId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVendors>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsGet(name, latitude, longitude, userId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all vendors associated with the currently authenticated user.
         * @summary Get all vendors for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsGetvendorsbyUserIdGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsGetvendorsbyUserIdGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsGetvendorsbyUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a vendor
         * @param {string} id The ID of the vendor to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a vendor by its ID
         * @param {string} id The ID of the vendor to retrieve.
         * @param {number} [latitude] User\&#39;s current latitude to calculate distance to the vendor.
         * @param {number} [longitude] User\&#39;s current longitude to calculate distance to the vendor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsIdGet(id: string, latitude?: number, longitude?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorWithDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsIdGet(id, latitude, longitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a vendor\'s details
         * @param {UpdateVendorPayload} updateVendorPayload 
         * @param {string} id The ID of the vendor to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsIdPatch(updateVendorPayload: UpdateVendorPayload, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsIdPatch(updateVendorPayload, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new vendor profile linked to the authenticated user. Default opening hours from 9:00 to 18:00 are created automatically for all days of the week.
         * @summary Create a new vendor
         * @param {CreateVendorPayload} createVendorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsPost(createVendorPayload: CreateVendorPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsPost(createVendorPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VendorApi - factory interface
 */
export const VendorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VendorApiFp(configuration)
    return {
        /**
         * 
         * @summary Accept a pending order
         * @param {string} orderId The ID of the order to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdAcceptPatch(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.orderOrderIdAcceptPatch(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Decline a pending order
         * @param {string} orderId The ID of the order to decline.
         * @param {DeclineOrderPayload} [declineOrderPayload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdDeclinePatch(orderId: string, declineOrderPayload?: DeclineOrderPayload, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.orderOrderIdDeclinePatch(orderId, declineOrderPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the assigned shopper or delivery person to update an item\'s status during shopping (e.g., found, not found, suggest replacement).
         * @summary Update the shopping status of an order item
         * @param {UpdateOrderItemShoppingStatusPayload} updateOrderItemShoppingStatusPayload 
         * @param {string} orderId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdItemsItemIdUpdateShoppingStatusPatch(updateOrderItemShoppingStatusPayload: UpdateOrderItemShoppingStatusPayload, orderId: string, itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrderItemWithRelations> {
            return localVarFp.orderOrderIdItemsItemIdUpdateShoppingStatusPatch(updateOrderItemShoppingStatusPayload, orderId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark an order as \'currently shopping\'
         * @param {string} orderId The ID of the order to start shopping for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdStartShoppingPatch(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.orderOrderIdStartShoppingPatch(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get orders for a vendor\'s dashboard
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderVendorOrdersGet(status?: OrderStatus, options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorOrder>> {
            return localVarFp.orderVendorOrdersGet(status, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
         * @summary Get trending vendor products
         * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTrendingGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTrendingVendorProducts> {
            return localVarFp.productVendorTrendingGet(vendorId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of vendors. Can be filtered by name and sorted by proximity if latitude and longitude are provided. If the user is authenticated, it also returns the number of items in their cart for each vendor.
         * @summary Get a paginated list of vendors
         * @param {string} [name] Filter vendors by name (case-insensitive search).
         * @param {number} [latitude] User\&#39;s current latitude to sort vendors by distance.
         * @param {number} [longitude] User\&#39;s current longitude to sort vendors by distance.
         * @param {string} [userId] Filter vendors by the user who owns them.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsGet(name?: string, latitude?: number, longitude?: number, userId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedVendors> {
            return localVarFp.vendorsGet(name, latitude, longitude, userId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all vendors associated with the currently authenticated user.
         * @summary Get all vendors for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsGetvendorsbyUserIdGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorWithRelations>> {
            return localVarFp.vendorsGetvendorsbyUserIdGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a vendor
         * @param {string} id The ID of the vendor to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VendorWithRelations> {
            return localVarFp.vendorsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a vendor by its ID
         * @param {string} id The ID of the vendor to retrieve.
         * @param {number} [latitude] User\&#39;s current latitude to calculate distance to the vendor.
         * @param {number} [longitude] User\&#39;s current longitude to calculate distance to the vendor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdGet(id: string, latitude?: number, longitude?: number, options?: RawAxiosRequestConfig): AxiosPromise<VendorWithDetails> {
            return localVarFp.vendorsIdGet(id, latitude, longitude, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a vendor\'s details
         * @param {UpdateVendorPayload} updateVendorPayload 
         * @param {string} id The ID of the vendor to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdPatch(updateVendorPayload: UpdateVendorPayload, id: string, options?: RawAxiosRequestConfig): AxiosPromise<VendorWithRelations> {
            return localVarFp.vendorsIdPatch(updateVendorPayload, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new vendor profile linked to the authenticated user. Default opening hours from 9:00 to 18:00 are created automatically for all days of the week.
         * @summary Create a new vendor
         * @param {CreateVendorPayload} createVendorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsPost(createVendorPayload: CreateVendorPayload, options?: RawAxiosRequestConfig): AxiosPromise<VendorWithRelations> {
            return localVarFp.vendorsPost(createVendorPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VendorApi - object-oriented interface
 */
export class VendorApi extends BaseAPI {
    /**
     * 
     * @summary Accept a pending order
     * @param {string} orderId The ID of the order to accept.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdAcceptPatch(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
        return VendorApiFp(this.configuration).orderOrderIdAcceptPatch(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Decline a pending order
     * @param {string} orderId The ID of the order to decline.
     * @param {DeclineOrderPayload} [declineOrderPayload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdDeclinePatch(orderId: string, declineOrderPayload?: DeclineOrderPayload, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
        return VendorApiFp(this.configuration).orderOrderIdDeclinePatch(orderId, declineOrderPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the assigned shopper or delivery person to update an item\'s status during shopping (e.g., found, not found, suggest replacement).
     * @summary Update the shopping status of an order item
     * @param {UpdateOrderItemShoppingStatusPayload} updateOrderItemShoppingStatusPayload 
     * @param {string} orderId 
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdItemsItemIdUpdateShoppingStatusPatch(updateOrderItemShoppingStatusPayload: UpdateOrderItemShoppingStatusPayload, orderId: string, itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrderItemWithRelations> {
        return VendorApiFp(this.configuration).orderOrderIdItemsItemIdUpdateShoppingStatusPatch(updateOrderItemShoppingStatusPayload, orderId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark an order as \'currently shopping\'
     * @param {string} orderId The ID of the order to start shopping for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdStartShoppingPatch(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
        return VendorApiFp(this.configuration).orderOrderIdStartShoppingPatch(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get orders for a vendor\'s dashboard
     * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderVendorOrdersGet(status?: OrderStatus, options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorOrder>> {
        return VendorApiFp(this.configuration).orderVendorOrdersGet(status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
     * @summary Get trending vendor products
     * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorTrendingGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTrendingVendorProducts> {
        return VendorApiFp(this.configuration).productVendorTrendingGet(vendorId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of vendors. Can be filtered by name and sorted by proximity if latitude and longitude are provided. If the user is authenticated, it also returns the number of items in their cart for each vendor.
     * @summary Get a paginated list of vendors
     * @param {string} [name] Filter vendors by name (case-insensitive search).
     * @param {number} [latitude] User\&#39;s current latitude to sort vendors by distance.
     * @param {number} [longitude] User\&#39;s current longitude to sort vendors by distance.
     * @param {string} [userId] Filter vendors by the user who owns them.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsGet(name?: string, latitude?: number, longitude?: number, userId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedVendors> {
        return VendorApiFp(this.configuration).vendorsGet(name, latitude, longitude, userId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all vendors associated with the currently authenticated user.
     * @summary Get all vendors for the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsGetvendorsbyUserIdGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorWithRelations>> {
        return VendorApiFp(this.configuration).vendorsGetvendorsbyUserIdGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a vendor
     * @param {string} id The ID of the vendor to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VendorWithRelations> {
        return VendorApiFp(this.configuration).vendorsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a vendor by its ID
     * @param {string} id The ID of the vendor to retrieve.
     * @param {number} [latitude] User\&#39;s current latitude to calculate distance to the vendor.
     * @param {number} [longitude] User\&#39;s current longitude to calculate distance to the vendor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsIdGet(id: string, latitude?: number, longitude?: number, options?: RawAxiosRequestConfig): AxiosPromise<VendorWithDetails> {
        return VendorApiFp(this.configuration).vendorsIdGet(id, latitude, longitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a vendor\'s details
     * @param {UpdateVendorPayload} updateVendorPayload 
     * @param {string} id The ID of the vendor to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsIdPatch(updateVendorPayload: UpdateVendorPayload, id: string, options?: RawAxiosRequestConfig): AxiosPromise<VendorWithRelations> {
        return VendorApiFp(this.configuration).vendorsIdPatch(updateVendorPayload, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new vendor profile linked to the authenticated user. Default opening hours from 9:00 to 18:00 are created automatically for all days of the week.
     * @summary Create a new vendor
     * @param {CreateVendorPayload} createVendorPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsPost(createVendorPayload: CreateVendorPayload, options?: RawAxiosRequestConfig): AxiosPromise<VendorWithRelations> {
        return VendorApiFp(this.configuration).vendorsPost(createVendorPayload, options).then((request) => request(this.axios, this.basePath));
    }
}
