/* tslint:disable */
/* eslint-disable */
/**
 * PardoMart Node API
 * API documentation for the PardoMart Node.js application.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@pardomart.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { CreateProductPayload } from '../models';
// @ts-ignore
import type { CreateVendorProductPayload } from '../models';
// @ts-ignore
import type { CreateVendorProductWithBarcodePayload } from '../models';
// @ts-ignore
import type { PaginatedTrendingVendorProducts } from '../models';
// @ts-ignore
import type { PaginatedVendorProducts } from '../models';
// @ts-ignore
import type { Product } from '../models';
// @ts-ignore
import type { ProductWithRelations } from '../models';
// @ts-ignore
import type { UpdateProductBasePayload } from '../models';
// @ts-ignore
import type { UpdateVendorProductPayload } from '../models';
// @ts-ignore
import type { VendorProduct } from '../models';
// @ts-ignore
import type { VendorProductWithRelations } from '../models';
/**
 * ProductApi - axios parameter creator
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a base product by its barcode
         * @param {string} barcode The barcode of the product to find.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productBarcodeGet: async (barcode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'barcode' is not null or undefined
            assertParamExists('productBarcodeGet', 'barcode', barcode)
            const localVarPath = `/product/barcode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (barcode !== undefined) {
                localVarQueryParameter['barcode'] = barcode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all base products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a base product
         * @param {string} id The ID of the base product to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productIdDelete', 'id', id)
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a base product
         * @param {UpdateProductBasePayload} updateProductBasePayload 
         * @param {string} id The ID of the base product to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productIdPatch: async (updateProductBasePayload: UpdateProductBasePayload, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateProductBasePayload' is not null or undefined
            assertParamExists('productIdPatch', 'updateProductBasePayload', updateProductBasePayload)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productIdPatch', 'id', id)
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductBasePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new base product in the system. This is the generic version of a product, not tied to a specific vendor.
         * @summary Create a base product
         * @param {CreateProductPayload} createProductPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productPost: async (createProductPayload: CreateProductPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProductPayload' is not null or undefined
            assertParamExists('productPost', 'createProductPayload', createProductPayload)
            const localVarPath = `/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProductPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get base products by tag IDs
         * @param {Array<string>} tagIds An array of tag IDs to filter products by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productTagsIdsGet: async (tagIds: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagIds' is not null or undefined
            assertParamExists('productTagsIdsGet', 'tagIds', tagIds)
            const localVarPath = `/product/tags/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tagIds) {
                localVarQueryParameter['tagIds'] = tagIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all vendor-specific products from all stores owned by a particular user. This can be used by an admin or the user themselves.
         * @summary Get all products from all vendors belonging to a user
         * @param {string} userId The ID of the user whose vendor products are to be fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUserUserIdGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('productUserUserIdGet', 'userId', userId)
            const localVarPath = `/product/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a vendor-specific product by barcode
         * @param {string} barcode The barcode of the product.
         * @param {string} vendorId The ID of the vendor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorBarcodeGet: async (barcode: string, vendorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'barcode' is not null or undefined
            assertParamExists('productVendorBarcodeGet', 'barcode', barcode)
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('productVendorBarcodeGet', 'vendorId', vendorId)
            const localVarPath = `/product/vendor/barcode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (barcode !== undefined) {
                localVarQueryParameter['barcode'] = barcode;
            }

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a vendor product by scanning a barcode. If the base product doesn\'t exist, it\'s created first.
         * @summary Create a vendor product via barcode scan
         * @param {CreateVendorProductWithBarcodePayload} createVendorProductWithBarcodePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorBarcodePost: async (createVendorProductWithBarcodePayload: CreateVendorProductWithBarcodePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVendorProductWithBarcodePayload' is not null or undefined
            assertParamExists('productVendorBarcodePost', 'createVendorProductWithBarcodePayload', createVendorProductWithBarcodePayload)
            const localVarPath = `/product/vendor/barcode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVendorProductWithBarcodePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get vendor products by category
         * @param {string} vendorId The ID of the vendor.
         * @param {string} categoryId The ID of the category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorCategoryGet: async (vendorId: string, categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('productVendorCategoryGet', 'vendorId', vendorId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('productVendorCategoryGet', 'categoryId', categoryId)
            const localVarPath = `/product/vendor/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all vendor products with filtering and pagination
         * @param {string} [name] Filter by product name (case-insensitive contains).
         * @param {string} [vendorId] Filter by vendor ID.
         * @param {string} [productId] Filter by base product ID.
         * @param {Array<string>} [categoryIds] Filter by an array of category IDs.
         * @param {Array<string>} [tagIds] Filter by an array of tag IDs.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorGet: async (name?: string, vendorId?: string, productId?: string, categoryIds?: Array<string>, tagIds?: Array<string>, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/vendor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (categoryIds) {
                localVarQueryParameter['categoryIds'] = categoryIds;
            }

            if (tagIds) {
                localVarQueryParameter['tagIds'] = tagIds;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a vendor-specific product
         * @param {string} id The ID of the vendor product to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productVendorIdDelete', 'id', id)
            const localVarPath = `/product/vendor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a vendor-specific product by its ID
         * @param {string} id The ID of the vendor product to find.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productVendorIdGet', 'id', id)
            const localVarPath = `/product/vendor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a vendor-specific product
         * @param {UpdateVendorProductPayload} updateVendorProductPayload 
         * @param {string} id The ID of the vendor product to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorIdPatch: async (updateVendorProductPayload: UpdateVendorProductPayload, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateVendorProductPayload' is not null or undefined
            assertParamExists('productVendorIdPatch', 'updateVendorProductPayload', updateVendorProductPayload)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productVendorIdPatch', 'id', id)
            const localVarPath = `/product/vendor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVendorProductPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a product listing for a specific vendor.
         * @summary Create a vendor-specific product
         * @param {CreateVendorProductPayload} createVendorProductPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorPost: async (createVendorProductPayload: CreateVendorProductPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVendorProductPayload' is not null or undefined
            assertParamExists('productVendorPost', 'createVendorProductPayload', createVendorProductPayload)
            const localVarPath = `/product/vendor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVendorProductPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get vendor products by tag IDs
         * @param {Array<string>} tagIds An array of tag IDs to filter vendor products by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTagsIdsGet: async (tagIds: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagIds' is not null or undefined
            assertParamExists('productVendorTagsIdsGet', 'tagIds', tagIds)
            const localVarPath = `/product/vendor/tags/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tagIds) {
                localVarQueryParameter['tagIds'] = tagIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
         * @summary Get trending vendor products
         * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTrendingGet: async (vendorId?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/vendor/trending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a base product by its barcode
         * @param {string} barcode The barcode of the product to find.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productBarcodeGet(barcode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productBarcodeGet(barcode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productBarcodeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all base products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a base product
         * @param {string} id The ID of the base product to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a base product
         * @param {UpdateProductBasePayload} updateProductBasePayload 
         * @param {string} id The ID of the base product to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productIdPatch(updateProductBasePayload: UpdateProductBasePayload, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productIdPatch(updateProductBasePayload, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new base product in the system. This is the generic version of a product, not tied to a specific vendor.
         * @summary Create a base product
         * @param {CreateProductPayload} createProductPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productPost(createProductPayload: CreateProductPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productPost(createProductPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get base products by tag IDs
         * @param {Array<string>} tagIds An array of tag IDs to filter products by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productTagsIdsGet(tagIds: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productTagsIdsGet(tagIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productTagsIdsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all vendor-specific products from all stores owned by a particular user. This can be used by an admin or the user themselves.
         * @summary Get all products from all vendors belonging to a user
         * @param {string} userId The ID of the user whose vendor products are to be fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUserUserIdGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorProduct>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUserUserIdGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productUserUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a vendor-specific product by barcode
         * @param {string} barcode The barcode of the product.
         * @param {string} vendorId The ID of the vendor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorBarcodeGet(barcode: string, vendorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorProductWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorBarcodeGet(barcode, vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorBarcodeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a vendor product by scanning a barcode. If the base product doesn\'t exist, it\'s created first.
         * @summary Create a vendor product via barcode scan
         * @param {CreateVendorProductWithBarcodePayload} createVendorProductWithBarcodePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorBarcodePost(createVendorProductWithBarcodePayload: CreateVendorProductWithBarcodePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorProductWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorBarcodePost(createVendorProductWithBarcodePayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorBarcodePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get vendor products by category
         * @param {string} vendorId The ID of the vendor.
         * @param {string} categoryId The ID of the category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorCategoryGet(vendorId: string, categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorProductWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorCategoryGet(vendorId, categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorCategoryGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all vendor products with filtering and pagination
         * @param {string} [name] Filter by product name (case-insensitive contains).
         * @param {string} [vendorId] Filter by vendor ID.
         * @param {string} [productId] Filter by base product ID.
         * @param {Array<string>} [categoryIds] Filter by an array of category IDs.
         * @param {Array<string>} [tagIds] Filter by an array of tag IDs.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorGet(name?: string, vendorId?: string, productId?: string, categoryIds?: Array<string>, tagIds?: Array<string>, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVendorProducts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorGet(name, vendorId, productId, categoryIds, tagIds, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a vendor-specific product
         * @param {string} id The ID of the vendor product to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a vendor-specific product by its ID
         * @param {string} id The ID of the vendor product to find.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorProductWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a vendor-specific product
         * @param {UpdateVendorProductPayload} updateVendorProductPayload 
         * @param {string} id The ID of the vendor product to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorIdPatch(updateVendorProductPayload: UpdateVendorProductPayload, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorProductWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorIdPatch(updateVendorProductPayload, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a product listing for a specific vendor.
         * @summary Create a vendor-specific product
         * @param {CreateVendorProductPayload} createVendorProductPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorPost(createVendorProductPayload: CreateVendorProductPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorProductWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorPost(createVendorProductPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get vendor products by tag IDs
         * @param {Array<string>} tagIds An array of tag IDs to filter vendor products by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorTagsIdsGet(tagIds: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorProductWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorTagsIdsGet(tagIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorTagsIdsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
         * @summary Get trending vendor products
         * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorTrendingGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTrendingVendorProducts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorTrendingGet(vendorId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorTrendingGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductApi - factory interface
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a base product by its barcode
         * @param {string} barcode The barcode of the product to find.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productBarcodeGet(barcode: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductWithRelations> {
            return localVarFp.productBarcodeGet(barcode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all base products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<ProductWithRelations>> {
            return localVarFp.productGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a base product
         * @param {string} id The ID of the base product to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.productIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a base product
         * @param {UpdateProductBasePayload} updateProductBasePayload 
         * @param {string} id The ID of the base product to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productIdPatch(updateProductBasePayload: UpdateProductBasePayload, id: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductWithRelations> {
            return localVarFp.productIdPatch(updateProductBasePayload, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new base product in the system. This is the generic version of a product, not tied to a specific vendor.
         * @summary Create a base product
         * @param {CreateProductPayload} createProductPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productPost(createProductPayload: CreateProductPayload, options?: RawAxiosRequestConfig): AxiosPromise<ProductWithRelations> {
            return localVarFp.productPost(createProductPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get base products by tag IDs
         * @param {Array<string>} tagIds An array of tag IDs to filter products by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productTagsIdsGet(tagIds: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<ProductWithRelations>> {
            return localVarFp.productTagsIdsGet(tagIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all vendor-specific products from all stores owned by a particular user. This can be used by an admin or the user themselves.
         * @summary Get all products from all vendors belonging to a user
         * @param {string} userId The ID of the user whose vendor products are to be fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUserUserIdGet(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorProduct>> {
            return localVarFp.productUserUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a vendor-specific product by barcode
         * @param {string} barcode The barcode of the product.
         * @param {string} vendorId The ID of the vendor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorBarcodeGet(barcode: string, vendorId: string, options?: RawAxiosRequestConfig): AxiosPromise<VendorProductWithRelations> {
            return localVarFp.productVendorBarcodeGet(barcode, vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a vendor product by scanning a barcode. If the base product doesn\'t exist, it\'s created first.
         * @summary Create a vendor product via barcode scan
         * @param {CreateVendorProductWithBarcodePayload} createVendorProductWithBarcodePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorBarcodePost(createVendorProductWithBarcodePayload: CreateVendorProductWithBarcodePayload, options?: RawAxiosRequestConfig): AxiosPromise<VendorProductWithRelations> {
            return localVarFp.productVendorBarcodePost(createVendorProductWithBarcodePayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get vendor products by category
         * @param {string} vendorId The ID of the vendor.
         * @param {string} categoryId The ID of the category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorCategoryGet(vendorId: string, categoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorProductWithRelations>> {
            return localVarFp.productVendorCategoryGet(vendorId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all vendor products with filtering and pagination
         * @param {string} [name] Filter by product name (case-insensitive contains).
         * @param {string} [vendorId] Filter by vendor ID.
         * @param {string} [productId] Filter by base product ID.
         * @param {Array<string>} [categoryIds] Filter by an array of category IDs.
         * @param {Array<string>} [tagIds] Filter by an array of tag IDs.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorGet(name?: string, vendorId?: string, productId?: string, categoryIds?: Array<string>, tagIds?: Array<string>, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedVendorProducts> {
            return localVarFp.productVendorGet(name, vendorId, productId, categoryIds, tagIds, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a vendor-specific product
         * @param {string} id The ID of the vendor product to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VendorProduct> {
            return localVarFp.productVendorIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a vendor-specific product by its ID
         * @param {string} id The ID of the vendor product to find.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VendorProductWithRelations> {
            return localVarFp.productVendorIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a vendor-specific product
         * @param {UpdateVendorProductPayload} updateVendorProductPayload 
         * @param {string} id The ID of the vendor product to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorIdPatch(updateVendorProductPayload: UpdateVendorProductPayload, id: string, options?: RawAxiosRequestConfig): AxiosPromise<VendorProductWithRelations> {
            return localVarFp.productVendorIdPatch(updateVendorProductPayload, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a product listing for a specific vendor.
         * @summary Create a vendor-specific product
         * @param {CreateVendorProductPayload} createVendorProductPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorPost(createVendorProductPayload: CreateVendorProductPayload, options?: RawAxiosRequestConfig): AxiosPromise<VendorProductWithRelations> {
            return localVarFp.productVendorPost(createVendorProductPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get vendor products by tag IDs
         * @param {Array<string>} tagIds An array of tag IDs to filter vendor products by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTagsIdsGet(tagIds: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorProductWithRelations>> {
            return localVarFp.productVendorTagsIdsGet(tagIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
         * @summary Get trending vendor products
         * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTrendingGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTrendingVendorProducts> {
            return localVarFp.productVendorTrendingGet(vendorId, page, size, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @summary Get a base product by its barcode
     * @param {string} barcode The barcode of the product to find.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productBarcodeGet(barcode: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productBarcodeGet(barcode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all base products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productGet(options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a base product
     * @param {string} id The ID of the base product to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a base product
     * @param {UpdateProductBasePayload} updateProductBasePayload 
     * @param {string} id The ID of the base product to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productIdPatch(updateProductBasePayload: UpdateProductBasePayload, id: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productIdPatch(updateProductBasePayload, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new base product in the system. This is the generic version of a product, not tied to a specific vendor.
     * @summary Create a base product
     * @param {CreateProductPayload} createProductPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productPost(createProductPayload: CreateProductPayload, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productPost(createProductPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get base products by tag IDs
     * @param {Array<string>} tagIds An array of tag IDs to filter products by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productTagsIdsGet(tagIds: Array<string>, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productTagsIdsGet(tagIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all vendor-specific products from all stores owned by a particular user. This can be used by an admin or the user themselves.
     * @summary Get all products from all vendors belonging to a user
     * @param {string} userId The ID of the user whose vendor products are to be fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productUserUserIdGet(userId: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productUserUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a vendor-specific product by barcode
     * @param {string} barcode The barcode of the product.
     * @param {string} vendorId The ID of the vendor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorBarcodeGet(barcode: string, vendorId: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorBarcodeGet(barcode, vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a vendor product by scanning a barcode. If the base product doesn\'t exist, it\'s created first.
     * @summary Create a vendor product via barcode scan
     * @param {CreateVendorProductWithBarcodePayload} createVendorProductWithBarcodePayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorBarcodePost(createVendorProductWithBarcodePayload: CreateVendorProductWithBarcodePayload, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorBarcodePost(createVendorProductWithBarcodePayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get vendor products by category
     * @param {string} vendorId The ID of the vendor.
     * @param {string} categoryId The ID of the category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorCategoryGet(vendorId: string, categoryId: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorCategoryGet(vendorId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all vendor products with filtering and pagination
     * @param {string} [name] Filter by product name (case-insensitive contains).
     * @param {string} [vendorId] Filter by vendor ID.
     * @param {string} [productId] Filter by base product ID.
     * @param {Array<string>} [categoryIds] Filter by an array of category IDs.
     * @param {Array<string>} [tagIds] Filter by an array of tag IDs.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorGet(name?: string, vendorId?: string, productId?: string, categoryIds?: Array<string>, tagIds?: Array<string>, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorGet(name, vendorId, productId, categoryIds, tagIds, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a vendor-specific product
     * @param {string} id The ID of the vendor product to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a vendor-specific product by its ID
     * @param {string} id The ID of the vendor product to find.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a vendor-specific product
     * @param {UpdateVendorProductPayload} updateVendorProductPayload 
     * @param {string} id The ID of the vendor product to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorIdPatch(updateVendorProductPayload: UpdateVendorProductPayload, id: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorIdPatch(updateVendorProductPayload, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a product listing for a specific vendor.
     * @summary Create a vendor-specific product
     * @param {CreateVendorProductPayload} createVendorProductPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorPost(createVendorProductPayload: CreateVendorProductPayload, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorPost(createVendorProductPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get vendor products by tag IDs
     * @param {Array<string>} tagIds An array of tag IDs to filter vendor products by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorTagsIdsGet(tagIds: Array<string>, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorTagsIdsGet(tagIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
     * @summary Get trending vendor products
     * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorTrendingGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorTrendingGet(vendorId, page, size, options).then((request) => request(this.axios, this.basePath));
    }
}

